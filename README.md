# PITCH HARMONIZER FOR TREBLE INSTRUMENTS 
#### Video Demo: <https://www.youtube.com/watch?v=XYz9iVcOWFg>
#### Description:
This program is designed to record a user with a treble instrument. Upon starting the program, the user will be notified that the program is recording. It will record for 15 seconds. After the recording ends, the pitches from the user will be parsed through and the program will output a 15 second WAV file that will have harmonized a 3 pitch chord in sine waves above the fundamental pitches provided by the user. 

In the get_user_recording function, the users recording will be written to a wav file. Deepgram's tutorials for recording audio were used for implementing this function [(https://deepgram.com/learn/best-python-audio-manipulation-tools#recording-audio-data-with-python)]. I've set it up to exit the program if the user does not have a microphone plugged in. the auto_tune library is then called to assist intonation issues in the users input. 

In generate_pitch_table, I made a csv file that lists out the name of each pitch, it's standard frequency, and the octave it is in from C0 to B8. I then read from that csv file in my main project file and appended them into a list of dictionaries for later use.

In parse_pitches, I first set a series of variables to study the input file from the user (time, frequency, and confidence) using the crepe library. When first testing this library out with pure sine waves generated from audacity, I noticed the condifence was only above .8 when a distinc pitch was present. I then iterated through the three variable lists and set a boolean variable to ensure that I was only grabbing the start time of a pitch that was found with at least .8 confidence and the end time of that pitch. I then used the pitch table I had generated from my previous function to determine the specific pitch being played. The main reason this is only for treble instruments is apparent when establishing these specific pitches. Higher notes have frequencies further apart, and their pitches (with an acceptable amount of intonation variance) can be caught with this program +- 7 hz. Lower instruments would need a seperate function outside of the scope of this project. 

The generate_pitches function was set up in a separate file named new_tones.py. I made a 2D list of pitches that will make up a CM7 chord based on the fundamental which is established at the 0 index of each list. The function in this file generates a list of dictionaries that will be used to generate new wave files to overlay the original input file. It first checks to see if the first pitch found starts at any point after the start of the WAV file. It then will append the list with a "silent" file, that is the length of the difference of the pitches start time and the beginning of the WAV file. It then checks to see if the pitch found is the same as the next pitch in the list. If it is, it will then append the list with the length of the pitch being played, and a frequency that matches a note in 2d list labeled chord_chart based on the fundamental. The index chosen is based on where in the chord the function is building the list. This is iterated through 3 times so that index changes based on which iteration this function is being called. This can be changed for future use if a user would like to alter the chord charts or add to them. The chord chart must match the iterations (minus one to account for the fundamental) to avoid an index error. All time between each pitch is appended as another silent pitch to make sure the final wav files match in length. 

In generate_tone_waves, the function takes the note list from the generate_pitches function and produces wav files one by one. It then returns the wave_file count to be used for the combine_files function. The combine_files function, which uses the tutorial from Deepgram to implement, iterates through these wav files, and stitches them together one at a time until it's one full wav file to overlay. the file_overlay first will overlay the original wav file in the first iteration, and then overlay the newly produced file from each iteration. The clean_data function, removes all of the wav files used to produce the final file labled "final_wave.wav". This is the fully produced wav for the user to listen to. It is then played using the play_new function which used Deepgrams tutorial to implement. 